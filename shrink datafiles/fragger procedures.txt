CREATE OR REPLACE PROCEDURE FRAGMENT_TS(TABLESPACE_NAME IN VARCHAR2, segment_size_m IN NUMBER DEFAULT 10) AS
BEGIN
	FILLUP_TS(TABLESPACE_NAME);
	HOLLOWOUT_TS(TABLESPACE_NAME);
END;
/


CREATE OR REPLACE PROCEDURE FILLUP_TS(TABLESPACE_NAME IN VARCHAR2, segment_size_m IN NUMBER DEFAULT 10) AS
	i				NUMBER := 1;
	TS_NAME			VARCHAR(30);
	ts_free_k		NUMBER;
	tab_size_k		NUMBER;
	ddl				VARCHAR2(4000);
	dml				VARCHAR2(4000);
	e_tsfull		exception;
	e_tableexists	exception;
	e_tempfull		exception;
	e_cant_create_table exception;
	PRAGMA EXCEPTION_INIT(e_tempfull, -01652);
	PRAGMA EXCEPTION_INIT(e_tsfull, -01653);
	PRAGMA EXCEPTION_INIT(e_cant_create_table, -01658);
	PRAGMA EXCEPTION_INIT(e_tableexists, -00955);
BEGIN
	TS_NAME := UPPER(TABLESPACE_NAME); 
	select NVL(sum(bytes),0)/1024 into ts_free_k from user_free_space where tablespace_name = ts_name;
	IF ts_free_k < 100 THEN
		DBMS_OUTPUT.PUT_LINE('Tablespace ' || ts_name || ' ALREADY filled to brim');
	ELSE
		WHILE ts_free_k > 100 LOOP
			BEGIN
				ddl := 'create table fragment_ts_' || i || ' tablespace ' || TS_NAME || ' as select * from user_objects';
				EXECUTE IMMEDIATE ddl;
				
				select NVL(sum(bytes)/1024,0) into tab_size_k from user_segments where segment_name = 'fragment_ts_' || i;
				--DBMS_OUTPUT.PUT_LINE('tab_size_k '|| tab_size_k);
				WHILE tab_size_k <= segment_size_m * 1024 LOOP
					dml := 'insert into fragment_ts_' || i || ' select * from fragment_ts_' || i ;
					EXECUTE IMMEDIATE dml;
					commit;
					select NVL(sum(bytes)/1024,0) into tab_size_k from user_segments where segment_name = upper('fragment_ts_' || i);
				END LOOP;
			EXCEPTION
				WHEN e_tableexists THEN
					NULL;
			END;
			i := i + 1;
		END LOOP;
	
	END IF;
EXCEPTION
	WHEN e_tsfull THEN
		DBMS_OUTPUT.PUT_LINE('DONE: Tablespace ' || ts_name || ' filled to brim');
	WHEN e_tempfull THEN
		DBMS_OUTPUT.PUT_LINE('DONE: Tablespace ' || ts_name || ' ALMOST filled to brim.');
END;
/

CREATE OR REPLACE PROCEDURE HOLLOWOUT_TS(TABLESPACE_NAME IN VARCHAR2, segment_size_m IN NUMBER DEFAULT 10) AS
	x 		NUMBER;
	minx 	NUMBER;
	maxx 	NUMBER;
	TOGGLE	BOOLEAN:= FALSE;
	TS_NAME VARCHAR2(30);
	
	CURSOR v_seg_cur IS
		SELECT TABLE_NAME FROM DBA_TABLES WHERE TABLESPACE_NAME = TS_NAME AND TABLE_NAME LIKE 'FRAGMENT_TS_%';
BEGIN
	TS_NAME := UPPER(TABLESPACE_NAME);
	FOR segrow IN v_seg_cur LOOP
		IF TOGGLE THEN
			execute immediate 'drop table ' || segrow.TABLE_NAME || ' purge';
			TOGGLE := FALSE;
		ELSE
			TOGGLE := TRUE;
		
			--DBMS_OUTPUT.PUT_LINE('emptying table '||segrow.TABLE_NAME);
			execute immediate 'select min(object_id),max(object_id) from ' || segrow.TABLE_NAME into minx,maxx;
			x := minx;
			--DBMS_OUTPUT.PUT_LINE('minx '||minx);
			WHILE x < maxx LOOP
				execute immediate 'DELETE FROM ' || segrow.TABLE_NAME || ' WHERE OBJECT_ID IN (SELECT OBJECT_ID FROM ' || segrow.TABLE_NAME || ' WHERE OBJECT_ID BETWEEN ' || X || ' AND ' || TO_CHAR(X + 1000) || ')';
				--DBMS_OUTPUT.PUT_LINE('DELETE FROM ' || segrow.TABLE_NAME || ' WHERE OBJECT_ID IN (SELECT OBJECT_ID FROM ' || segrow.TABLE_NAME || ' WHERE OBJECT_ID BETWEEN X AND X + 1000)');
				commit;
				x := x + 2000;
			END LOOP;
		END IF;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE('DONE: Tablespace ' || ts_name || ' hollowed out');
END;
/
